---
title: "Using the Census2016 Package to enrich election analysis"
author: "Stephen Bush"
output:
  html_document:
    toc: yes
    toc_depth: "2"
    number_sections: yes
    toc_float: yes
    fig_width: 12
    fig_height: 8
    df_print: paged
    code_folding: hide
  html_notebook:
    toc: yes
    toc_depth: 2
    number_sections: yes
    toc_float: yes
    fig_width: 12
    fig_height: 8
    df_print: paged
    code_folding: hide
---

<style type="text/css">
.main-container {
max-width: 800px;
margin-left: auto;
margin-right: auto;
}
</style>

<style>
pre {
overflow-x: auto;
}
pre code {
word-wrap: normal;
white-space: pre;
}
</style>

# Introduction

It looks like Raustats might not be what I am looking for to get SLA level census data quickly. Let"s try Census2016 from Hugh Parsonage.

```{r, warning=FALSE, echo=FALSE, error=FALSE, message=FALSE}
library(tidyverse)
library(Census2016)
library(eechidna)
library(RColorBrewer)
library(janitor)
library(kableExtra)
library(skimr)
library(rvest)
library(MASS)
library(car)
library(gvlma)
library(caret)
library(glmnet)
library(gbm)
library(rsample)
library(tidymodels)
library(stacks)
library(ranger)

knitr::opts_chunk$set(message = FALSE)
options(scipen = 1000)
options(width = 800)

if (file.exists("./Data/polling_place_2pp_clean.RDS")) {
  polling_place_2pp_clean <- readRDS("./Data/polling_place_2pp_clean.RDS")
} else {
  source('./Code/1_Data_Sourcing.R')
  source('./Code/2_Data_Cleaning.R')
}

```


Look at variable summaries

```{r}
skimr::skim_tee(polling_place_2pp_clean)
```


# Visualising Basic Statistics
```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(x = LNP_Percent / 100)) +
  stat_density(geom = "line", colour = "blue") +
  theme_classic(base_size = 16) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: LNP 2 Party Preferred Percentage",
       x = "2PP Percentage", y = "Density",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(x = ALP_Percent / 100)) +
  stat_density(geom = "line", colour = "red") +
  theme_classic(base_size = 16) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       x = "2PP Percentage", y = "Density",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(x = Swing / 100)) +
  stat_density(geom = "line", colour = "purple") +
  theme_classic(base_size = 16) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: Swing to Incumbent", x = "Swing",
       y = "Density", subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(x = median_household_income)) +
  stat_density(geom = "line", colour = "purple") +
  theme_classic(base_size = 16) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Census: Median Income", x = "Median Income",
       y = "Density", subtitle = "by Polling Booth, Unweighted")
```

## State Breakdowns

Can we look at these distributions by state?

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(x = ALP_Percent / 100, colour = StateAb)) +
  stat_density(geom = "line", position = "dodge") +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       x = "2PP Percentage", y = "Frequency",
       subtitle = "by Polling Booth, Unweighted")
```

What about by median income

```{r, fig.width=12, fig.height=12, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = median_household_income,
             colour = StateAb)) +
  geom_point() +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       x = "Booth Median Income",
       y = "ALP 2pp Percentage", subtitle = "by Polling Booth, Unweighted") +
  facet_wrap(~StateAb, nrow = 4)
```

What about comparing NSW electorates? There seems to be an odd separation in income bands for low ALP 2pp. Could this be a regional vs city difference? 

```{r, error=F, message=F, warning=F}
fp_booth_16 <- firstpref_pollingbooth_download() %>%
  filter(year == 2016)
```


```{r, error=F, message=F, warning=F}
polling_2cp <- read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseTcpByCandidateByPollingPlaceDownload-20499.csv", skip = 1)

polling_2pp <- read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseTppByPollingPlaceDownload-20499.csv", skip = 1)

fp_booth_2016 <- read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-NSW.csv", skip = 1) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-VIC.csv", skip = 1)) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-QLD.csv", skip = 1)) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-SA.csv", skip = 1)) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-WA.csv", skip = 1)) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-TAS.csv", skip = 1)) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-NT.csv", skip = 1)) %>%
  rbind(read_csv("https://results.aec.gov.au/20499/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-20499-ACT.csv", skip = 1))
```

```{r, error=F, message=F, warning=F}
coalition_contest_2016 <- fp_booth_2016 %>%
  group_by(DivisionNm, PartyNm, HistoricElected) %>%
  summarise(OrdinaryVotes = sum(OrdinaryVotes)) %>%
  filter(PartyNm %in% c("Liberal", "Country Liberals (NT)",
                        "Liberal National Party of Queensland",
                        "The Nationals")) %>%
  group_by(DivisionNm) %>%
  top_n(1) %>%
  dplyr::select(DivisionNm, PartyNm)
```

If we look at a couple of the states where high income booths tend to vote strongly for the coalition as well as lower income booths, we can see that some (but not all) of the lower income booths are contested by The Nationals. This indicares (not surprisingly) that Nationals voters and Liberal voters are different socio-economically, or possibly that city and country coalition voters differ. 

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  mutate(DivisionNm = stringr::str_to_title(DivisionNm)) %>%
  inner_join(coalition_contest_2016) %>%
  filter(StateAb == "NSW") %>%
  ggplot(aes(y = ALP_Percent / 100, x = median_household_income,
             colour = PartyNm)) +
  geom_point(size = 3) +
  theme_classic(base_size = 16) +
  scale_color_manual(values = c("blue", "dark green")) +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       x = "Booth Median Income",
       y = "ALP 2pp Percentage", colour = "Coalition Party",
       subtitle = "by Polling Booth, Unweighted (NSW)")
```


```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  mutate(DivisionNm = stringr::str_to_title(DivisionNm)) %>%
  inner_join(coalition_contest_2016) %>%
  filter(StateAb == "VIC") %>%
  ggplot(aes(y = ALP_Percent / 100, x = median_household_income,
             colour = PartyNm)) +
  geom_point(size = 3) +
  theme_classic(base_size = 16) +
  scale_color_manual(values = c("blue", "dark green")) +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       x = "Booth Median Income",
       y = "ALP 2pp Percentage", colour = "Coalition Party",
       subtitle = "by Polling Booth, Unweighted (VIC)")
```

This effect is less clear in states where the Nationals aren't as prominent, either because the Nationals aren't as prominent (SA, WA, TAS), or are merged with the Liberals (QLD).  
```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  mutate(DivisionNm = stringr::str_to_title(DivisionNm)) %>%
  inner_join(coalition_contest_2016) %>%
  filter(StateAb == "WA") %>%
  ggplot(aes(y = ALP_Percent / 100, x = median_household_income,
             colour = PartyNm)) +
  geom_point(size = 3) +
  theme_classic(base_size = 16) +
  scale_color_manual(values = c("blue", "dark green")) +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       x = "Booth Median Income",
       y = "ALP 2pp Percentage", colour = "Coalition Party",
       subtitle = "by Polling Booth, Unweighted (WA)")
```


Perhaps we would be better off using the geographical classifications from the AEC.

```{r, error=F, message=F, warning=F}
webpage <-
  read_html("http://results.aec.gov.au/20499/Website/HouseDivisionClassifications-20499-NAT.htm")

division_classifications <- webpage %>%
  html_nodes("#divisionClassifications") %>%
  html_table(fill = TRUE) %>%
  .[[1]]

division_classifications <- division_classifications %>%
  filter(Division != "Total Enrolment")

polling_place_2pp_clean <- polling_place_2pp_clean %>%
  mutate(Division = stringr::str_to_title(DivisionNm)) %>%
  inner_join(division_classifications)
```

The graph below shows that the booths that have a low ALP 2pp and a low median income are primarily rural booths. This relationship seems stronger than the Lib/Nat split.
```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  filter(StateAb == "NSW") %>%
  ggplot(aes(y = ALP_Percent / 100, x = median_household_income,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Booth Median Income", colour = "Region",
       subtitle = "by Polling Booth, Unweighted (NSW)")
```

Looking at all states we see a similar relationship, although less strong than in NSW.
```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = median_household_income,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Median Booth Income", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

What about some of the other variables?

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = average_household_size,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Average Household Size", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_female, colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent Female", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  dplyr::select(ALP_Percent, Swing, median_age, median_household_income,
                average_household_size, persons_per_bedroom, median_weekly_rent,
                median_annual_mortgage, percent_female, percent_defacto,
                percent_born_in_australia,
                percent_unit, percent_mortgage, percent_rent) %>%
  cor %>%
  kable()
```

Note that there appear to be lots of NAs for the housing data. Need to fix/impute.

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = persons_per_bedroom,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Persons per Bedroom", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_unit, colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent of Dwellings - Unit", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_mortgage,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent of Dwellings - Under Mortgage", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_rent, colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent of Dwellings - Renting", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_indig, colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent Indigeneous", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_born_in_australia,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent Born in Australia", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean %>%
  ggplot(aes(y = ALP_Percent / 100, x = percent_defacto,
             colour = Demographic)) +
  geom_point(size = 1) +
  theme_classic(base_size = 16) + scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "2016 Election: ALP 2 Party Preferred Percentage",
       y = "ALP 2pp Percentage",
       x = "Percent in a Defacto Relationship", colour = "Region",
       subtitle = "by Polling Booth, Unweighted")
```

## Some maps




# Simple Model Building

## Linear Models

Can we build a simple linear model to predict 2pp

```{r, error=F, message=F, warning=F}
alp_2pp_lm_demog <-
  lm(ALP_Percent ~ median_household_income * Demographic + percent_indig +
       percent_female + percent_defacto + percent_born_in_australia +
       percent_rent + median_weekly_rent + median_age,
     data = polling_place_2pp_clean)

summary(alp_2pp_lm_demog)
anova(alp_2pp_lm_demog)
plot(alp_2pp_lm_demog)
vif(alp_2pp_lm_demog)

gv_alp_2pp_lm_demog <- gvlma(alp_2pp_lm_demog)
summary(gv_alp_2pp_lm_demog)
```


```{r, error=F, message=F, warning=F}
alp_2pp_lm_demog <-
  lm(ALP_Percent ~ median_household_income + Demographic + percent_indig +
       percent_defacto + percent_born_in_australia +
       percent_rent + median_weekly_rent + median_age,
     data = polling_place_2pp_clean)

summary(alp_2pp_lm_demog)
anova(alp_2pp_lm_demog)
plot(alp_2pp_lm_demog)
vif(alp_2pp_lm_demog)
crPlots(alp_2pp_lm_demog)
ceresPlots(alp_2pp_lm_demog)

gv_alp_2pp_lm_demog <- gvlma(alp_2pp_lm_demog)
summary(gv_alp_2pp_lm_demog)
```

We know that income is important in the non-rural areas, so it might be worth adding an interaction between rural and non-rural and income.

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean <- polling_place_2pp_clean %>%
  mutate(NonRural_Demographic = if_else(Demographic == "Rural", 1, 0),
         ALP_Percent_2013 = ALP_Percent + Swing)

alp_2pp_lm_demog <-
  lm(ALP_Percent ~ median_household_income + Demographic + percent_indig +
       percent_defacto + percent_born_in_australia +
       percent_rent + median_weekly_rent + median_age +
       NonRural_Demographic:median_household_income,
     data = polling_place_2pp_clean)

summary(alp_2pp_lm_demog)
anova(alp_2pp_lm_demog)
plot(alp_2pp_lm_demog)
vif(alp_2pp_lm_demog)

gv_alp_2pp_lm_demog <- gvlma(alp_2pp_lm_demog)
summary(gv_alp_2pp_lm_demog)
```


## Lasso Regression

Using a lasso regression, 

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean_na <- na.omit(polling_place_2pp_clean) %>%
  dplyr::select(ALP_Percent, StateAb, median_age, median_household_income,
                average_household_size, persons_per_bedroom, median_weekly_rent,
                median_annual_mortgage,  percent_female, percent_defacto,
                percent_married, percent_indig, percent_born_in_australia,
                percent_unit, percent_mortgage, percent_rent, Demographic)
# Inspect the data
sample_n(polling_place_2pp_clean_na, 3)
# Split the data into training and test set
set.seed(123)
training_samples <- polling_place_2pp_clean_na$ALP_Percent %>%
  createDataPartition(p = 0.8, list = FALSE)
train_data  <- polling_place_2pp_clean_na[training_samples, ]
test_data <- polling_place_2pp_clean_na[-training_samples, ]

# Dummy code categorical predictor variables
x <- model.matrix(ALP_Percent~., train_data)[, -1]
# Convert the outcome (class) to a numerical variable
y <- train_data$ALP_Percent

cv_lasso <- cv.glmnet(x, y, alpha = 1, family = "gaussian")

# Fit the final model on the training data
alp_2pp_lasso_demog <- glmnet(x, y, alpha = 1, family = "gaussian",
                              lambda = cv_lasso$lambda.min)
# Display regression coefficients
coef(alp_2pp_lasso_demog)

summary(alp_2pp_lasso_demog)

alp_2pp_lasso_demog$dev.ratio

# Make predictions on the test data
x_test <- model.matrix(ALP_Percent ~., test_data)[, -1]
predictions <- alp_2pp_lasso_demog %>% predict(newx = x_test)
# Model accuracy
observed <- test_data$ALP_Percent

plot(predictions, observed)
cor(predictions, observed)

cor(predictions, observed)^2

Metrics::rmse(actual = observed,
              predicted = predictions)
```


What if we include the 2pp from the last election. It appears that Swing is defined as the swing to the Coalition between 2013 and 2016. So if we add the swing to the 2016 2pp, then we obtain the 2013 2pp.

When using a Linear Model, we can get an R^2 of about 84%
```{r, error=F, message=F, warning=F}
polling_place_2pp_clean <- polling_place_2pp_clean %>%
  mutate(logit_ALP_Percent =
           log((ALP_Percent / 100) / (1 - ALP_Percent / 100)),
         logit_ALP_Percent_2013 =
           log((ALP_Percent_2013 / 100) / (1 - ALP_Percent_2013 / 100))) %>%
  filter(!is.nan(logit_ALP_Percent)) %>%
  filter(!is.na(logit_ALP_Percent)) %>%
  filter(!is.infinite(logit_ALP_Percent)) %>%
  filter(!is.nan(logit_ALP_Percent_2013)) %>%
  filter(!is.na(logit_ALP_Percent_2013)) %>%
  filter(!is.infinite(logit_ALP_Percent_2013))

alp_2pp_lm_demog_lag <-
  lm(logit_ALP_Percent ~ percent_indig + percent_defacto +
       percent_rent + median_weekly_rent + median_age +
       NonRural_Demographic * median_household_income + logit_ALP_Percent_2013,
     data = polling_place_2pp_clean)

summary(alp_2pp_lm_demog_lag)
anova(alp_2pp_lm_demog_lag)
plot(alp_2pp_lm_demog_lag)
vif(alp_2pp_lm_demog_lag)

gv_alp_2pp_lm_demog_lag <- gvlma(alp_2pp_lm_demog_lag)
summary(alp_2pp_lm_demog_lag)
```

It would be interesting to see whether 2013 alone is a good predictor. Fitting this model gives an R^2 of 82.7%. This means that the other variables add a bit, but not a huge amount. 
```{r, error=F, message=F, warning=F}
alp_2pp_lm_demog_lag <-
  lm(logit_ALP_Percent ~ logit_ALP_Percent_2013,
     data = polling_place_2pp_clean)

summary(alp_2pp_lm_demog_lag)
anova(alp_2pp_lm_demog_lag)
plot(alp_2pp_lm_demog_lag)
```

There are three outlying values - let"s explore these

```{r, error=F, message=F, warning=F}
polling_place_2pp_clean[c(2079, 7267, 2758), ]
```

These booths have fewer than 40 electors, and fewer than 5 for one of the two parties. They are also "non-standard" booths.

It might be interesting to see which booths deviate from the division mean.


## Trying GBM

Can we fit a gradient boosting machine to improve fit (while trading off raw explainability)

```{r, error=F, message=F, warning=F}
polling_place_2pp_gbm <- polling_place_2pp_clean %>%
  clean_names() %>%
  dplyr::select(-year, -division_nm, -polling_place_id, -polling_place,
                -division, -premises_post_code, -division_id, -state,
                -enrolment, -successful_party, -seat_status, -alp_percent,
                -lnp_percent, -lnp_votes, -alp_votes, -total_votes, -swing) %>%
  mutate(state_ab = factor(state_ab),
         demographic = factor(demographic),
         previous_party = factor(previous_party),
         previous_seat_status = factor(previous_seat_status))


polling_place_2pp_split <- initial_split(polling_place_2pp_gbm, prop = .8)
polling_place_2pp_train <- training(polling_place_2pp_split)
polling_place_2pp_test  <- testing(polling_place_2pp_split)


polling_place_2pp_gbm1 <- gbm::gbm(logit_alp_percent ~.,
                                   data = polling_place_2pp_train,
                                   distribution = "gaussian",
                                   verbose = F,
                                   shrinkage = 0.1,
                                   interaction.depth = 2,
                                   n.minobsinnode = 10,
                                   n.trees = 5000,
                                   cv.folds = 10)

perf_gbm1 <- gbm.perf(polling_place_2pp_gbm1, method = "cv")
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_prediction_1 <- stats::predict(
  object = polling_place_2pp_gbm1,
  newdata = polling_place_2pp_test,
  n.trees = perf_gbm1)
rmse_fit1 <- Metrics::rmse(actual = polling_place_2pp_test$logit_alp_percent,
                           predicted = polling_place_2pp_prediction_1)
print(rmse_fit1)
```


```{r, error=F, message=F, warning=F}
data.frame(actual = polling_place_2pp_test$logit_alp_percent,
           predicted = polling_place_2pp_prediction_1) %>%
  ggplot(aes(x = predicted, y = actual)) + geom_point() +
  geom_abline(slope = 1, intercept = 0, colour = "blue") +
  theme_classic()
```


```{r, error=F, message=F, warning=F}
gbm::plot.gbm(polling_place_2pp_gbm1, i.var = 8)
```

When looking at variable importance, it is clear that the most important factor is the 2pp vote in the previous election.

```{r, error=F, message=F, warning=F}
polling_place_2pp_effects <-
  tibble::as_tibble(gbm::summary.gbm(polling_place_2pp_gbm1, plotit = FALSE))
polling_place_2pp_effects %>% utils::head(n = 15)
```

```{r, error=F, message=F, warning=F}
polling_place_2pp_effects %>%
  # arrange descending to get the top influencers
  dplyr::arrange(desc(rel.inf)) %>%
  # sort to top 10
  dplyr::top_n(10) %>%
  # plot these data using columns
  ggplot(aes(x = forcats::fct_reorder(.f = var,
                                      .x = rel.inf),
             y = rel.inf,
             fill = rel.inf)) +
  geom_col() +
  # flip
  coord_flip() +
  # format
  scale_color_brewer(palette = "Dark2") +
  theme(axis.title = element_text()) +
  theme_classic() +
  xlab("Features") +
  ylab("Relative Influence") +
  ggtitle("Top 10 Drivers of 2pp vote")
```


### Using the Stacks package to compare models

We can use the skim function to summarise the covariates and outcome variables that we will be modelling on. 

```{r}
polling_place_2pp_model <- polling_place_2pp_clean %>%
  clean_names() %>%
  dplyr::select(-year, -division_nm, -polling_place_id, -polling_place,
                -division, -premises_post_code, -division_id, -state,
                -enrolment, -successful_party, -seat_status, -alp_percent,
                -lnp_percent, -lnp_votes, -alp_votes, -total_votes, -swing,
                -alp_percent_2013) %>%
  mutate(state_ab = factor(state_ab),
         demographic = factor(demographic),
         previous_party = factor(previous_party),
         previous_seat_status = factor(previous_seat_status))

skim(polling_place_2pp_model)
```

We can see that there is some missing data for latitude, longitude, and dwelling statistics. We will impute these using KNN imputation.



```{r}
polling_place_2pp_split <- initial_split(polling_place_2pp_model, prop = .8)
polling_place_2pp_train <- training(polling_place_2pp_split)
polling_place_2pp_test  <- testing(polling_place_2pp_split)


training_folds <- vfold_cv(polling_place_2pp_train, v = 10)

polling_place_2pp_rec <- recipe(logit_alp_percent ~ ., 
                                data = polling_place_2pp_train) %>% 
  step_knnimpute(all_predictors()) %>% 
  step_dummy(all_predictors(), -all_numeric()) 

metric <- metric_set(rmse)
```

Create some candidate models
```{r}
ctrl_grid <- control_stack_grid()
ctrl_res <- control_stack_resamples()
```

#### Linear Regression

```{r}
lm_spec <- 
  linear_reg() %>% 
  set_engine("lm")

lm_wflow <- 
  workflow() %>%
  add_model(lm_spec) %>%
  add_recipe(polling_place_2pp_rec)

lm_resample <- 
  fit_resamples(
    lm_wflow,
    resamples = training_folds,
    metrics = metric,
    control = ctrl_res
  )
```

#### Linear regression with lasso

```{r}
lasso_spec <- 
  linear_reg(penalty = tune("pen"), mixture = tune("mix")) %>% 
  set_engine("glmnet")

lasso_wflow <- 
  workflow() %>%
  add_model(lasso_spec) %>%
  add_recipe(polling_place_2pp_rec)

#Fix
lasso_resample <- 
  tune_grid(
    lasso_wflow,
    resamples = training_folds,
    metrics = metric,
    grid = 6,
    control = ctrl_res
  )
```

#### Random Forest

```{r}
random_forest_spec <- 
  rand_forest(mode = "regression", mtry = tune("num_pred"), 
              min_n = tune("min_n")) %>% 
  set_engine("ranger")

random_forest_wflow <- 
  workflow() %>%
  add_model(random_forest_spec) %>%
  add_recipe(polling_place_2pp_rec)

#Fix
random_forest_resample <- 
  tune_grid(
    random_forest_wflow,
    resamples = training_folds,
    metrics = metric,
    grid = 6,
    control = ctrl_res
  )
```


#### K nearest neighbours

```{r}
knn_spec <-
  nearest_neighbor(
    mode = "regression", 
    neighbors = tune("k")
  ) %>%
  set_engine("kknn")

knn_wflow <- 
  workflow() %>%
  add_model(knn_spec) %>%
  add_recipe(polling_place_2pp_rec)

#Fix
knn_resample <- 
  tune_grid(
    knn_wflow,
    resamples = training_folds,
    metrics = metric,
    grid = 6,
    control = ctrl_res
  )
```

#### Gradient boosting machine
```{r}
gbm_spec <- 
  boost_tree(
    min_n = tune("min_n"),
    tree_depth = tune("tree_depth"),
    learn_rate = tune("learn_rate"),
    loss_reduction = tune("loss_reduction")
  ) %>%
  set_engine("xgboost") %>%
  set_mode("regression")

gbm_wflow <- 
  workflow() %>%
  add_model(gbm_spec) %>%
  add_recipe(polling_place_2pp_rec)

#Fix
gbm_resample <- 
  tune_grid(
    gbm_wflow,
    resamples = training_folds,
    metrics = metric,
    grid = 100,
    control = ctrl_res
  )
```

```{r}
gbm_resample$.metrics[[1]] %>% 
  arrange(.estimate)
```



#### Support Vector Machine

```{r}
svm_spec <- 
  svm_rbf(
    cost = tune("cost"), 
    rbf_sigma = tune("sigma")
  ) %>%
  set_engine("kernlab") %>%
  set_mode("regression")


svm_wflow <- 
  workflow() %>%
  add_model(svm_spec) %>%
  add_recipe(polling_place_2pp_rec)

#Fix
svm_resample <- 
  tune_grid(
    svm_wflow,
    resamples = training_folds,
    metrics = metric,
    grid = 6,
    control = ctrl_res
  )
```


#### Creating a ensemble of these models

```{r}
polling_place_2pp_stack <-
  stacks() %>%
  add_candidates(lm_resample) %>%
  add_candidates(lasso_resample) %>%
  add_candidates(random_forest_resample) %>%
  add_candidates(knn_resample) %>%
  add_candidates(gbm_resample) %>%
  add_candidates(svm_resample)
```


```{r}
polling_place_2pp_stack <-
  polling_place_2pp_stack %>%
  blend_predictions()
```


```{r}
theme_set(theme_classic(base_size = 16))
autoplot(polling_place_2pp_stack)

autoplot(polling_place_2pp_stack, type = "weights")
```

```{r}
polling_place_2pp_stack <-
  polling_place_2pp_stack %>%
  fit_members()
```

```{r}
collect_parameters(polling_place_2pp_stack, "lasso_resample") %>% 
  arrange(desc(coef))
collect_parameters(polling_place_2pp_stack, "knn_resample")
collect_parameters(polling_place_2pp_stack, "random_forest_resample")
collect_parameters(polling_place_2pp_stack, "gbm_resample")
collect_parameters(polling_place_2pp_stack, "svm_resample")
```

#### Testing 

```{r}
polling_place_2pp_test <- 
  polling_place_2pp_test %>%
  bind_cols(predict(polling_place_2pp_stack, .)) %>% 
  rename(ensemble_pred = .pred)

ggplot(polling_place_2pp_test) +
  aes(x = logit_alp_percent, 
      y = ensemble_pred) +
  geom_point() + 
  coord_obs_pred()
```


```{r}
member_preds <- 
  polling_place_2pp_test %>%
  dplyr::select(logit_alp_percent) %>%
  bind_cols(predict(polling_place_2pp_stack, polling_place_2pp_test,
                    members = TRUE))

map_dfr(member_preds, rmse, truth = logit_alp_percent, data = member_preds) %>%
  mutate(member = colnames(member_preds)) %>% 
  arrange(.estimate)

map_dfr(member_preds, rsq, truth = logit_alp_percent, data = member_preds) %>%
  mutate(member = colnames(member_preds)) %>% 
  arrange(desc(.estimate))
```

Interestingly, an ensemble only gives us a 1.5% increase in R^2 over a linear model, with the best random forests outperforming linear regression by about 1%

## Outlying booths

It might be interesting to see which booths are not predicted well by the models.

```{r}
polling_place_2pp_ensemble_test <- polling_place_2pp_test %>% 
  mutate(residual = logit_alp_percent - ensemble_pred) 

polling_place_2pp_ensemble_test %>% 
  ggplot(aes(y = residual, x = logit_alp_percent)) + geom_point()
```

It seems that there are few booths with a residual larger than 0.75. Let's look at these

```{r}
polling_place_2pp_ensemble_test %>% 
  filter(abs(residual) > 0.75) %>% 
  arrange(desc(abs(residual)))
```

It appears that these booths might have had large swings. The below plot looks at the residual based on the swing.

```{r}
polling_place_2pp_ensemble_test <- polling_place_2pp_ensemble_test %>% 
  mutate(swing = logit_alp_percent - logit_alp_percent_2013)

polling_place_2pp_ensemble_test %>% 
  ggplot(aes(y = abs(residual), x = swing)) + geom_point()
```

So the booths that we could not predict well were ones that had big swings.

```{r}
lm_fit <- lm_wflow %>% 
  fit(polling_place_2pp_train)

lm_fit %>% 
  pull_workflow_fit() %>% 
  tidy()
```

```{r}
lm_pred <- predict(lm_fit, polling_place_2pp_test) %>% 
  bind_cols(polling_place_2pp_test) %>% 
  rename(lm_pred = .pred) %>% 
  mutate(residual_lm = logit_alp_percent - lm_pred,
         residual_ensemble = logit_alp_percent - ensemble_pred)
```

How do the ensemble and linear model predictions compare?

```{r}
lm_pred %>% 
  ggplot(aes(y = ensemble_pred, x = lm_pred)) + geom_point()
```

So the predictions aren't that different.

```{r}
lm_pred %>% 
  ggplot(aes(y = abs(residual_ensemble), x = abs(residual_lm))) + geom_point() +
  geom_abline(intercept = 0, slope = 1)
```

# Predicting outcome based on some booths

To solve this problem, we need to predict the seat 2pp from the booth(s), which would be progressively reported through the night 2pp and/or booth swings.


# Where are the swings?

Summarise by Electorate

```{r}
library(ggthemes)
electorate_2pp <- polling_place_2pp_clean %>% 
  group_by(DivisionNm) %>% 
  summarise(ALP_Percent = weighted.mean(ALP_Percent, TotalVotes),
            ALP_Percent_2013 = weighted.mean(ALP_Percent_2013, TotalVotes)) %>% 
  mutate(Swing = ALP_Percent - ALP_Percent_2013) %>% 
  left_join(nat_data16 %>% 
              rename(DivisionNm = elect_div))


ggplot(aes(map_id=id), data=electorate_2pp) +
  geom_map(aes(fill=Swing), map=nat_map16, col = "grey50") +
  expand_limits(x=nat_map16$long, y=nat_map16$lat) + 
  theme_map() + coord_equal()
```


Summarise by postcode

```{r}
postcode_2pp <- polling_place_2pp_clean %>% 
  group_by(PremisesPostCode) %>% 
  summarise(ALP_Percent = weighted.mean(ALP_Percent, TotalVotes),
            ALP_Percent_2013 = weighted.mean(ALP_Percent_2013, TotalVotes)) %>% 
  mutate(Swing = ALP_Percent - ALP_Percent_2013)
```











